# 14 전역변수의문제점

## 14.1 변수의 생명 주기

### 14.1.1 지역 변수의 생명주기

- 함수가 호출되면 생성되고 함수가 종료되면 소멸
- 지역변수의 생명주기는 함수의 생명 주기와 일치

### 14.1.2 전역 변수의 생명주기

- var 키워드로 선언한 전역 변수의 생명주기는 전역 객체의 생명주기와 일치

## 14.2 전역 변수의 문제점

1. 암묵적 결함 : 모든 코드가 전역 변수를 참조하고 변경 가능하게 허용 / 변수의 유효범위가 커져 가독성이 떨어지고 의도치 않게 상태 변경 위험이 높아짐
2. 긴 생명 주기 : 메모리 리소스를 오랜 기간 소비
3. 스코프 체인 상에서 종점에 존재 : 전역변수는 맨 마지막에검색되어 검색 속도가 느림
4. 네임스페이스 오염 : 자바스크립트는 파일이 분리되어도 스코프를 공유하여 같은 이름으로 명명된 변수나 함수에서 오류 발생 가능성 높음

## 14.3 전역변수의 사용을 억제하는 방법

- 반드시 사용할 이유를 찾지 못할 때는 지역변수로 사용
- 변수 스코프는 좁으면 좋음

### 14.3.1 즉시 실행함수

- 코드를 즉시 실행 함수로 감싸면 모든 변수는 즉시 실행 함수의 지역변수가 됨

### 14.3.2 네임스페이스 객체

- 네임스페이스 역할을 담당할 객체를 생성하여 전역 변수처럼 사용하고 싶은 변수를 프로퍼티로 추가

```
var Myapp = {}
Myapp.name = 'Lee'
```

### 14.3.3 모듈 패턴

- 모듈 패턴 : 클래스를 모방하여 관련 변수와 함수를 모아 즉시 실행 함수로 감싸 모듈을 생성
- 전역변수 업제 및 캡슐화 구현 가능
- 캡슐화 : 객체 상태를 나타내는 프로퍼티와 프로퍼티를 참조하고 조작하는 동작인 메서드를 하나로 묶는 것

```
var Counter = (function () {
  var name = 0;

  return {
    increase() {
      return ++num
    },
    decrease() {
      return --num
    }
  };
}());
// private 변수는 외부 노출 x
console.log(Counter.num); // undefined
console.log(Couter.increase()); // 1
console.log(Couter.decrease()); // 0
```

### 14.3.4 ES6 모듈

- ES6 모듈은 파일 자체의 독자적 모듈 스코프를 제공
